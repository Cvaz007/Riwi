-- TEMPDB: es una extensión de la mameoria RAM
-- (pero es disco duro)......lo usa SQL SERVER 
-- para almacenar temporalmente datos para sus
-- procesos.

-- MSDB: la usa SQL SERVER para administrar las
-- bases de datos DISTRIBUIDAS de los usuarios.

-- MODEL: base de datos plantilla o formato inicial
-- para cualquier otra base de datos.

-- MASTER: Almacena los metadatos del sistema / motor/
--  bases de datos de los usuarios.
-- metadatos: datos que describen a otros datos.

-- FORMAS DE TRABAJAR EN UN MOTOR DE BDs
-- 1. MODO GRAFICO
-- 2. MODO COMANDO

-- CREAR LA BASE DE DATOS LIBRERIA POR COMANDO
CREATE DATABASE LIBRERIA  -- COMANDO SQL PARA CREAR BDs
-- QUE TIPO DE INSTRUCCION SQL ES?  DDL
-- SQL TIENE TRES TIPOS DE INSTRUCCIONES:

-- DDL: DATA DEFINITION LANGUAGE: GESTIONAN ESTRUCTURAS DE DATOS
-- DML: DATA MANIPULATION LANGUAGE: GESTIONAN DATOS
-- DCL: DATA CONTROL LANGUAGE: GESTIONA ACCESO A LOS DATOS

-- BORRA UNA BASE DE DATOS
DROP DATABASE LIBRERIA -- DDL

CREATE DATABASE FERIAFLORES

USE FERIAFLORES
-- CREAR LA TABLA ALCALDE
CREATE TABLE ALCALDE
(CEDULA  BIGINT PRIMARY KEY,
NOMBRE VARCHAR(30) NOT NULL,
EDAD SMALLINT,
FECHANAC DATE)

-- TIPOS DE DATOS
-- ENTERO: SMALLINT, BIGINT, INT
-- TEXTO:
-- CHAR: STRING DE LONGITUD FIJA
-- VARCHAR: STRING DE LONGITUD VARIABLE
-- TEXT: MUCHO STRING, MUCHO TEXTO

-- VAMOS A ALMACENAR EL SIGUIENTE TEXTO
-- DESARROLLO DE BASES DE DATOS: 28 CARACTERES
-- CHAR(40): ALMACENA TEXTO Y 12 ESPACIOS A LA DERECHA
-- VARCHAR(40): ALMACENA EL TEXTO

-- NCHAR
-- NVARCHAR
-- NTEXT

-- DESARROLLO DE BASES DE DATOS EN CHINO SE ESCRIBE ASI...
-- îUæîJÿ

-- IMPLICACIONES DE UNA CLAVE PRIMARIA
-- CARACTERISTICAS DE UNA PK
-- 1. UNICA, NO SE REPITE
-- 2. NO NULA

USE FERIAFLORES
SELECT * FROM CIUDAD

-- CRUD

-- INSERTAR NUEVAS TUPLAS A LAS TABLAS
-- COMANDO

INSERT INTO CIUDAD VALUES (90,'POPAYAN',800000)

INSERT INTO CIUDAD VALUES
(100,'PASTO',650000),
(110,'MONTERIA',810000),
(120,'CUCUTA',900000);


INSERT INTO CIUDAD VALUES
(130,'MANIZALES',NULL);
GO

INSERT INTO CIUDAD (NOMBRE, CODIGO) VALUES
('BUCARAMANGA', 140)

-- ACTUALIZAR DATOS
-- MEDELLIN TIENE YA 2100000 HABITANTES
UPDATE CIUDAD
SET NUMHABITANTES = 2100000
WHERE CODIGO = 10 -- CONDICION --- WHERE

-- CUCUTA YA SE LLAMA CUCUTA 2 Y TIENE 950000 HABITANTES.
-- HACER ESA ACTUALIZACION EN UN SOLO UPDATE
UPDATE CIUDAD
SET NOMBRE = 'CUCUTA 2', NUMHABITANTES = 950000
WHERE CODIGO = 120 AND CODIGO = 130
 -- AND    OR

 -- BORRADO DE DATOS -- BORRADO DE TUPLAS
 -- VAMOS A BORRAR LA CIUDAD MANIZALES

 DELETE FROM CIUDAD  -- DELETE BORRA TODA LA TUPLA
 WHERE CODIGO = 130 

 -- ******************************************* --
 -- **             CONSULTA                  ** --
 -- ******************************************* --
 -- INSTRUCCION SELECT
 -- SINTAXIS COMPLETA DE UN SELECT
 -- SELECT lista de campos que queremos imprimir
 -- FROM tabla(s) de donde vienen esos campos
 -- [WHERE condicion(es) a cumplir ]
 -- [GROUP BY campos de agrupamiento]
 -- [HAVING condicion(es) de grupo]
 -- [ORDER BY campos de agrupamiento]

 SELECT NOMBRE, NUMHABITANTES
 FROM CIUDAD
 WHERE NUMHABITANTES > 1000000

 -- USO DEL *
 SELECT CODIGO, NOMBRE, NUMHABITANTES
 FROM CIUDAD

 SELECT * -- IMPRIMA TODAS LAS COLUMNAS / CAMPOS
 FROM CIUDAD

 -- ADICIONARLE A LA TABLA ALCALDE UN NUEVO CAMPO,
 -- LLAMADO SUELDO, DE TIPO MONEY
 ALTER TABLE ALCALDE ADD SUELDO MONEY

 INSERT INTO ALCALDE VALUES 
 (6000,'JOSE ZAPATA',31,'1985-02-02',6900000)

 -- CONSULTAR NOMBRE, SUELDO Y EDAD DE LOS ALCALDES
 -- CUYA EDAD ES MAYOR A 40 AÑOS CUYO SUELDO ES
 -- MENOR A 4000000.

 SELECT NOMBRE, SUELDO, EDAD
 FROM ALCALDE
 WHERE EDAD > 40 AND SUELDO < 4000000
 
 SELECT NOMBRE, SUELDO, EDAD
 FROM ALCALDE
 WHERE (EDAD > 40 AND SUELDO < 4000000) OR EDAD < 20

 -- CONSULTAR NOMBRE Y EDAD DE ALCALDES QUE TENGAN
 -- ENTRE 20 Y 40 AÑOS DE EDAD.
select NOMBRE, EDAD
FROM ALCALDE
WHERE EDAD >=20 AND EDAD<=40  -- SQL ESTANDAR

SELECT NOMBRE, EDAD
FROM ALCALDE
WHERE EDAD BETWEEN 20 AND 40   -- SQL NO ESTANDAR

--CONSULTAR NOMBRE Y EDAD DE LOS ALCALDES CUYA EDAD ES
-- 25, 68, 90, 59, 19 o 33 AÑOS.
SELECT NOMBRE, EDAD
FROM ALCALDE
WHERE EDAD=25 or EDAD=68 or EDAD=90 or 
      EDAD=59 or EDAD=19 or EDAD=33;   -- SQL ESTANDAR

SELECT NOMBRE, EDAD
FROM ALCALDE
WHERE EDAD IN (25,68,90,59,19,33)  -- SQL NO ESTANDAR

-- CONSULTAR NOMBRE Y SUELDO DE LOS ALCALDES
-- CUYO NOMBRE COMIENCE POR LA LETRA M.

SELECT NOMBRE, SUELDO
FROM ALCALDE 
WHERE NOMBRE LIKE 'A%'    -- LIKE

-- TERMINE EN A.
SELECT NOMBRE, SUELDO
FROM ALCALDE 
WHERE NOMBRE LIKE '%A' 

-- CONTENGA LA LETRA S.
SELECT NOMBRE, SUELDO
FROM ALCALDE 
WHERE NOMBRE LIKE '%S%' 

-- FUNCIONES AGREGADAS
-- INSTRUCCIONES QUE CALCULAN ESTADISTICAS SIMPLES
-- SOBRE LOS DATOS
-- SUM: SUMA DE VALORES
-- AVG: PROMEDIO ARITMETICO DE VALORES
-- MIN: MINIMO VALOR
-- MAX: MAXIMO VALOR
-- COUNT: CANTIDAD DE VALORES

SELECT SUM(SUELDO) AS 'SUMA DE SUELDOS DE ALCALDES'
FROM ALCALDE

SELECT AVG(SUELDO)
FROM ALCALDE        -- PARA EL CALCULO TUVO EN CUENTA A
                    -- MARIA OSSA ?????  NO

SELECT MIN(EDAD)
FROM ALCALDE

SELECT MAX(EDAD) AS 'EDAD DEL ALCALDE MAS VIEJITO'
FROM ALCALDE

SELECT COUNT(SUELDO)
FROM ALCALDE

SELECT COUNT(*)
FROM ALCALDE

-- COMO PONERLE TITULOS PERSONALIZADOS A LAS COLUMNAS DEL 
-- RESULTADO DE UNA CONSULTA
SELECT NOMBRE AS  'NOMBRE DE ALCALDE', 
       EDAD  AS 'EDAD DEL ALCALDE'
FROM ALCALDE

-- CLAUSULAS VARIAS
SELECT LOWER(NOMBRE)  -- MINUSCULA
FROM ALCALDE

SELECT UPPER(NOMBRE)  -- MAYUSCULA
FROM ALCALDE

-- Veronica Zea
-- SQL SERVER: NO HAY FUNCION PARA ESO
-- ORACLE: FUNCION INITCAP

-- CONSULTAR NOMBRE Y FECHA DE NACIMIENTO
-- DE LOS ALCALDES NACIDOS EN EL AÑO 2001.
SELECT NOMBRE, FECHANAC
FROM ALCALDE
WHERE FECHANAC LIKE '2001%'  -- FORMA No. 1

SELECT NOMBRE, FECHANAC
FROM ALCALDE
WHERE YEAR(FECHANAC) = 2001

-- ALCALDES NACIDOS EN EL MES DE AGOSTO DE CUALQUIER
-- AÑO.

SELECT NOMBRE, FECHANAC
FROM ALCALDE
WHERE MONTH(FECHANAC) = 8

SELECT NOMBRE, FECHANAC
FROM ALCALDE
WHERE DAY(FECHANAC) = 30

-- ADICIONARLE A LA TABLA CIUDAD EL CAMPO
-- FECHA FUNDACION.
ALTER TABLE CIUDAD ADD FECHAFUN VARCHAR(10)

-- NOMBRE Y FECHA FUNDACION DE CIUDADES FUNDADAS EN EL
-- AÑO 1566

SELECT NOMBRE, FECHAFUN
FROM CIUDAD
WHERE FECHAFUN LIKE '%1566'  -- MANERA No. 1

SELECT NOMBRE, FECHAFUN
FROM CIUDAD
WHERE SUBSTRING(FECHAFUN, 7, 4) = 1566

-- CIUDADES FUNDADAS EN JULIO DE CUALQUIER AÑO
SELECT NOMBRE, FECHAFUN
FROM CIUDAD
WHERE SUBSTRING(FECHAFUN, 4, 2) = 07

-- CIUDADES FUNDADAS EL 23 DE CUALQUIER MES Y AÑO.
SELECT NOMBRE, FECHAFUN
FROM CIUDAD
WHERE SUBSTRING(FECHAFUN, 1,2) = 23

-- CUALIFICACION DE ATRIBUTOS: EXPLICITAMENTE DECIR CADA CAMPO
--      DE QUE TABLA VIENE.
-- 1. SIN CUALIFICAR ATRIBUTOS
SELECT CEDULA, NOMBRE, EDAD
FROM ALCALDE
WHERE EDAD > 40

-- 2. CUALIFICANDO ATRIBUTOS, SIN RENOMBRAR LA TABLA
SELECT ALCALDE.CEDULA, ALCALDE.NOMBRE, ALCALDE.EDAD
FROM ALCALDE
WHERE ALCALDE.EDAD > 40

-- 3. CUALIFICANDO ATRIBUTOS, RENOMBRANDO LA TABLA
SELECT A.CEDULA, A.NOMBRE, A.EDAD
FROM ALCALDE A  
WHERE A.EDAD > 40

-- CONSULTAR NOMBRE Y SUELDO DE ALCALDES MAYORES DE 30 AÑOS.
-- EL RESULTADO DEBE SALIR ORDENADO DESCENDENTEMENTE POR SUELDO.
SELECT A.NOMBRE, A.SUELDO
FROM ALCALDE A
WHERE A.EDAD>30
ORDER BY A.NOMBRE DESC

SELECT A.NOMBRE, A.SUELDO
FROM ALCALDE A
WHERE A.EDAD>30
ORDER BY A.SUELDO ASC

-- COMO ORDENAR UN RESULTADO POR VARIOS CAMPOS
SELECT A.NOMBRE, A.SUELDO, A.EDAD
FROM ALCALDE A
WHERE A.EDAD>30
ORDER BY A.EDAD ASC, SUELDO ASC

SELECT * FROM ALCALDE

UPDATE ALCALDE SET EDAD = 35 WHERE CEDULA = 4000

-- INSTRUCCION QUE ES SQL NO ESTANDAR
-- ES PROPIA DE SQL SERVER
-- CONSULTAR EL NOMBRE DEL ALCALDE MAS JOVEN.
-- INSTRUCCION TOP

SELECT TOP 1 A.NOMBRE
FROM ALCALDE A
ORDER BY A.EDAD ASC

-- SEGUNDA FORMA DE HACERSE
-- CONCEPTO DE SUBCONSULTAS
select A.nombre
from Alcalde A
where A.edad=(SELECT MIN(A.edad) FROM ALCALDE A)

-- CAMPOS TIPO IDENTITY: ES UN CAMPO AL CUAL EL SISTEMA
-- AUTOMATICAMENTE LE ASIGNA EL VALOR, DE ACUERDO A UN
-- VALOR INICIAL Y A UN INCREMENTO DEFINIDOS.

-- CREAR LA SIGUIENTE TABLA
CREATE TABLE PATROCINADOR
(NIT  BIGINT  PRIMARY KEY  IDENTITY(100,10),
NOMBRE VARCHAR(30) NOT NULL,
AÑOFUNDACION SMALLINT)

SELECT * FROM PATROCINADOR

-- INSERTAR UN NUEVO PATROCINADOR
INSERT INTO PATROCINADOR VALUES
('CARVAJAL S.A.',1990 )

-- RELACIONAR TABLAS

CREATE TABLE EDICION
(AÑO SMALLINT PRIMARY KEY,
FECHAINI DATE NOT NULL,
FECHAFIN DATE NOT NULL,
CEDALCALDE BIGINT)

-- EN ESTE MOMENTO, ALCALDE Y EDICION NO ESTAN 
-- RELACIONADAS ENTRE SI.

-- COMO RELACIONAR DOS TABLAS?
-- PARA QUÉ SE REALCIONAN LAS TABLAS?
-- PARA PRESERVAR LA INTEGRIDAD REFERENCIAL DE LA BD
-- ES QUE TODO VALOR DE FK CONCUERDE CON ALGUN VALOR
-- DE LA PK CON LA QUE SE RELACIONA.

-- CREAR LA TABLA VEHICULO

CREATE TABLE VEHICULO
(PLACA VARCHAR(6) PRIMARY KEY,
MARCA VARCHAR(30) NOT NULL,
MODELO SMALLINT,
PRECIO MONEY)

ALTER TABLE VEHICULO ADD CODCIUDAD SMALLINT

-- COMO SE RELACIONAN LAS TABLAS CIUDAD Y VEHICULO?
ALTER TABLE VEHICULO
ADD FOREIGN KEY(CODCIUDAD)
REFERENCES CIUDAD(CODIGO)

-- CLASE SEPTIEMBRE 14
USE FERIAFLORES
-- CREAR TABLA DESFILA
CREATE TABLE DESFILA
(AÑOED SMALLINT NOT NULL,
PLACAVEH VARCHAR(6) NOT NULL,
CANTOCUPANTES SMALLINT,
PRIMARY KEY(AÑOED, PLACAVEH))

ALTER TABLE DESFILA ADD FOREIGN KEY(AÑOED)
REFERENCES EDICION(AÑO)

ALTER TABLE DESFILA ADD FOREIGN KEY(PLACAVEH)
REFERENCES VEHICULO(PLACA)

-- INSERTAR DATOS EN VEHICULO
INSERT INTO VEHICULO VALUES 
('OLP099','RENAULT',2000,6500000,10),
('JUU900','MAZDA',1963,4780000,10),
('KIL650','MAZDA',1977,5600000,30),
('BHY650','TOYOTA',1980,3600000,40)

SELECT * FROM EDICION

-- INSERTAR DATOS EN DESFILA
INSERT INTO DESFILA VALUES
(2000,'OLP099',5),
(2001,'OLP099',7),
(2002,'OLP099',3),
(2001,'JUU900',15),
(2002,'KIL650',1),
(2003,'KIL650',6),
(2000,'BHY650',10),
(2001,'BHY650',7),
(2003,'BHY650',3)

-- RELACIONAR PATROCINADOR CON VEHICULO
ALTER TABLE PATROCINADOR ADD PLACAVEH VARCHAR(6)

ALTER TABLE PATROCINADOR ADD FOREIGN KEY(PLACAVEH)
REFERENCES VEHICULO(PLACA)

-- HACER UNA CONSULTA QUE IMPRIMA LO SIGUIENTE:
--    PLACA VEHICULO       TOTAL CANTIDAD OCUPANTES
--      OLP099...................  15
--      JUU900...................  15
--      KIL650...................   7
--      BHY650...................  20

SELECT D.PLACAVEH, SUM(D.CANTOCUPANTES) AS 'TOTAL DE OCUPANTES'
FROM DESFILA D
GROUP BY D.PLACAVEH  -- AGRUPA DATOS POR UN CAMPO

-- HACER LA MISMA CONSULTA ANTERIOR PERO QUE SOLO MUESTRE LOS 
-- VEHICULOS QUE EN TOTAL HAYAN TENIDO MAS DE 10 OCUPANTES.
SELECT D.PLACAVEH, SUM(D.CANTOCUPANTES) AS 'TOTAL'
FROM DESFILA D
GROUP BY D.PLACAVEH
HAVING SUM(D.CANTOCUPANTES) > 10

-- HAVING VS WHERE
-- HAVING: CONDICIONES A GRUPOS DE TUPLAS (GROUP BY)
-- WHERE: CONDICIONES A TUPLAS INDIVIDUALES DE LA TABLA

-- ************************************************************ --
-- **                     JOINS                              ** --
-- ************************************************************ --

-- HASTA EL MOMENTO, EN EL FROM HEMOS USADO UNA SOLA TABLA.

-- JOIN: CONSULTA DE DOS TABLAS "RELACIONADAS" DIRECTAMENTE ENTRE
--       SI.

-- HAY 3 TIPOS DE JOINS:
-- INNER JOIN
-- LEFT JOIN / RIGHT JOIN
-- FULL JOIN

-- CONSULTAR PLACA, MARCA DE CADA VEHICULO JUNTO CON EL NOMBRE DE 
-- LA CIUDAD DE DONDE PROVIENE.
-- PREGUNTAS A RESOLVER:
-- 1. CUANTAS "COSAS" ME ESTAN PIDIENDO IMPRIMIR?
-- 2. DE CUANTAS TABLAS PROVIENEN ESAS COSAS?
-- 3. CUANTAS TABLAS SE NECESITAN PARA HACER LA CONSULTA?
SELECT V.PLACA, V.MARCA, C.NOMBRE
FROM VEHICULO V INNER JOIN CIUDAD C
ON V.CODCIUDAD = C.CODIGO         -- SQL ESTANDAR

SELECT V.PLACA, V.MARCA, C.NOMBRE
FROM VEHICULO V, CIUDAD C
WHERE V.CODCIUDAD = C.CODIGO      -- SQL ESTANDAR

-- CONSULTAR EL NIT Y EL NOMBRE DEL PATROCINADOR JUNTO CON
-- LA PLACA Y MARCA DEL VEHICULO QUE PATROCINAN.
SELECT P.NIT, P.NOMBRE,V.PLACA, V.MARCA 
FROM VEHICULO V INNER JOIN PATROCINADOR P
ON P.PLACAVEH = V.PLACA

-- CONSULTAR EL NIT Y EL NOMBRE DEL PATROCINADOR JUNTO CON
-- LA PLACA Y MARCA DEL VEHICULO QUE PATROCINAN. TAMBIEN
-- DEBEN APARECER LOS PATROCINADORES QUE NO TIENEN
-- VEHICULO PATROCINADO.
SELECT P.NIT, P.NOMBRE,V.PLACA, V.MARCA 
FROM VEHICULO V RIGHT JOIN PATROCINADOR P
ON P.PLACAVEH = V.PLACA

-- PATROCINADOR SIN VEHICULOS. SOLO DEBEN SALIR LOS
-- PATROCINADORES SIN VEHICULO.
SELECT P.NIT, P.NOMBRE,V.PLACA, V.MARCA 
FROM PATROCINADOR P LEFT JOIN VEHICULO V
ON P.PLACAVEH = V.PLACA
WHERE V.PLACA IS NULL

-- VEHICULOS SIN PATROCINADOR
SELECT P.NIT, P.NOMBRE,V.PLACA, V.MARCA 
FROM PATROCINADOR P RIGHT JOIN VEHICULO V
ON P.PLACAVEH = V.PLACA

-- HACE TODO A LA VEZ: INNER, LEFT Y RIGHT
SELECT P.NIT, P.NOMBRE,V.PLACA, V.MARCA 
FROM PATROCINADOR P FULL JOIN VEHICULO V
ON P.PLACAVEH = V.PLACA

SELECT * FROM VEHICULO
SELECT * FROM CIUDAD

-- ******************************************************* --
-- **             CLASE SEPTIEMBRE 23                   ** --
-- ******************************************************* --
-- JOIN ENTRE TRES O MAS TABLAS.

-- CONSULTAR PLACA Y MARCA DE CADA VEHICULO, JUNTO CON EL
-- NOMBRE DE LA CIUDAD DE DONDE PROVIENE Y NOMBRE Y AÑO DE 
-- FUNDACION DE SUS PATROCINADORES.
USE FERIAFLORES
SELECT V.PLACA, V.MARCA, C.NOMBRE, P.NOMBRE, P.AÑOFUNDACION
FROM PATROCINADOR P INNER JOIN VEHICULO V
ON P.PLACAVEH = V.PLACA
INNER JOIN CIUDAD C
ON V.CODCIUDAD = C.CODIGO

-- CONSULTAR CEDULA Y NOMBRE DE LOS ALCALDES JUNTO CON LA PLACA
-- Y MARCA DE LOS VEHICULOS QUE HAN DESFILADO DURANTE SU
-- GOBIERNO.

-- DE CUANTAS TABLAS PROVIENEN LOS DATOS A IMPRIMIR? DOS
-- CUANTAS TABLAS NECESITO PARA HACER LA CONSULTA? CUATRO
SELECT A.CEDULA, A.NOMBRE, V.PLACA,V.MARCA
FROM VEHICULO V INNER JOIN DESFILA D
ON V.PLACA = D.PLACAVEH
INNER JOIN EDICION E
ON E.AÑO = D.AÑOED
INNER JOIN ALCALDE A
ON A.CEDULA = E.CEDALCALDE

-- CONSULTAR LA PLACA Y EL PRECIO DE CADA VEHICULO, JUNTO CON 
-- EL NOMBRE DE SUS PATROCINADORES, EL NOMBRE DE LA CIUDAD DE
-- DONDE VIENE Y EL AÑO EN QUE HA DESFILADO JUNTO CON SU
-- NUMERO DE OCUPANTES.

SELECT V.PLACA, V.PRECIO, P.NOMBRE, C.NOMBRE, D.AÑOED, 
       D.CANTOCUPANTES
FROM CIUDAD C INNER JOIN VEHICULO V
ON C.CODIGO = V.CODCIUDAD
INNER JOIN PATROCINADOR P
ON P.PLACAVEH = V.PLACA
INNER JOIN DESFILA D
ON D.PLACAVEH = V.PLACA

-- *************************************************** --
-- **           CLASE SEPTIEMBRE 28                 ** --
-- *************************************************** --
-- CONSULTAR NOMBRE Y AÑO DE FUNDACION DE PATROCINADORES
-- DE VEHICULOS QUE VENGAN DE CIUDADES DE MAS DE 2000000
-- DE HABITANTES, QUE HAYAN DESFILADO EN EDICIONES DONDE HAN
-- GOBERNADO ALCALDES QUE GANEN MAS DE 2000000 DE SUELDO.
-- LA CONSULTA DEBE SALIR ORDENADA DESCENDENTEMENTE POR NOMBRE
-- DE PATROCINADOR.
-- HACERLA EN DOS ETAPAS:
-- 1. LA VAN A HACER "A OJO" Y DAN LA RESPUESTA.
-- 2. ESCRIBEN LA INSTRUCCION SQL, EJECUTAN Y COMPARAN CON
--    LA RESPUESTA DEL PASO 1.
-- LO QUE VOY A IMPRIMIR, DE CUANTAS TABLAS VIENE? UNA
-- CUANTAS TABLAS NECESITO PARA HACER LA CONSULTA? TODAS, SEIS

SELECT P.NOMBRE AS 'NOMBRE PATROCINADOR',P.AÑOFUNDACION AS 'AÑO DE FUNDACION DEL PATROCINADOR'
FROM Patrocinador AS P INNER JOIN Vehiculo AS V
ON P.PLACAVEH = V.PLACA INNER JOIN Ciudad AS C
ON C.CODIGO = V.CODCIUDAD INNER JOIN Desfila AS D
ON D.PLACAVEH = V.PLACA INNER JOIN Edicion AS E
ON E.AÑO = D.AÑOED INNER JOIN Alcalde AS A
ON E.CEDALCALDE = A.CEDULA
WHERE C.NUMHABITANTES > 2000000 AND A.SUELDO > 2000000
ORDER BY P.NOMBRE DESC

SELECT P.NOMBRE, P.AÑOFUNDACION
FROM PATROCINADOR P INNER JOIN VEHICULO V
ON P.PLACAVEH = V.PLACA INNER JOIN CIUDAD C
ON V.CODCIUDAD = C.CODIGO INNER JOIN DESFILA D
ON V.PLACA = D.PLACAVEH INNER JOIN EDICION E
ON D.AÑOED = E.AÑO INNER JOIN ALCALDE A
ON E.CEDALCALDE = A.CEDULA
GROUP BY C.NUMHABITANTES, A.SUELDO, P.NOMBRE, P.AÑOFUNDACION
HAVING C.NUMHABITANTES > 2000000 AND A.SUELDO > 2000000
ORDER BY P.NOMBRE DESC

-- TEORIA DE CONJUNTOS
-- CONJUNTOS: TABLAS
-- ELEMENTOS: TUPLAS

-- CONSULTAR LOS DATOS DE LOS ALCALDES Y DE LOS PATROCINADORES DE
-- VEHICULOS. TODO DEBE SALIR EN UN MISMO RESULTADO.
-- OPERACION UNION
-- CONDICION 1. AMBAS TABLAS TIENEN QUE TENER LA MISMA CANTIDAD DE
--              CAMPOS.
-- CONDICION 2. CADA CAMPO CORRESPONDIENTE DEBE SER DEL MISMO
--              TIPO DE DATO
SELECT A.CEDULA, A.NOMBRE, A.EDAD, 'ALCALDE'
FROM ALCALDE A
UNION     -- INSTRUCCION QUE HACE LA UNION DE CONJUNTOS
SELECT P.NIT, P.NOMBRE, P.AÑOFUNDACION, 'PATROCINADOR'
FROM PATROCINADOR P

-- INTERSECCION
-- LOS ELEMENTOS QUE ESTAN EN AMBOS CONJUNTOS A LA VEZ.
SELECT * FROM ALCALDE

-- CONSULTAR LOS DATOS DE LOS ALCALDES QUE TAMBIEN SON
-- PATROCINADORES.
SELECT A.NOMBRE
FROM ALCALDE A
INTERSECT   -- INTERSECCION DE CONJUNTOS
SELECT P.NOMBRE
FROM PATROCINADOR P

-- DIFERENCIA
-- TODOS LOS ELEMENTOS QUE ESTAN EN UN CONJUNTO Y QUE NO ESTEN
-- EN OTRO CONJUNTO.
-- CONSULTAR LOS DATOS DE LOS ALCALDES QUE NO SON PATROCINADORES.
SELECT A.NOMBRE
FROM ALCALDE A
EXCEPT     -- DIFERENCIA DE CONJUNTOS
SELECT P.NOMBRE
FROM PATROCINADOR P

SELECT P.NOMBRE
FROM PATROCINADOR P
EXCEPT
SELECT A.NOMBRE
FROM ALCALDE A

-- ************************************************* --
--           CLASE SEPTIEMBRE 30                  ** --
-- ************************************************* --

USE FERIAFLORES
-- CHECK CONSTRAINTS

-- EJECUTAR LA SIGUIENTE INSTRUCCION
-- CHECK CONSTRAINT: CONDICION PUESTA A LOS VALORES DE UN 
--                   CAMPO DE UNA TABLA
ALTER TABLE ALCALDE ADD CHECK (EDAD > 20 AND EDAD < 100)
ALTER TABLE ALCALDE ADD CHECK (SUELDO BETWEEN 100000 AND 50000000)

ALTER TABLE PATROCINADOR ADD CHECK (NIT > 1 AND AÑOFUNDACION > 1600)

INSERT INTO ALCALDE VALUES
(1210, 'MARIA NUÑEZ', 80, '1940-10-10',3600000)

UPDATE ALCALDE
   SET EDAD = 120
   WHERE CEDULA = 1210

INSERT INTO ALCALDE VALUES
(1230, 'MARIA CALLE', 80, '1940-10-10',180000)
SELECT * FROM ALCALDE

INSERT INTO ALCALDE VALUES
(1220, 'CAROLINA PEREZ', 101, '1920-11-11',2600000)

SELECT * FROM CIUDAD

-- CREAR UN CHECK CONSTRAINT QUE PERMITA SOLAMENTE GRABAR
-- CIUDADES CUYO NOMBRE EMPIECE POR LAS LETRAS A, S o Z.

ALTER TABLE CIUDAD 
ADD CHECK(NOMBRE LIKE 'A%' OR NOMBRE LIKE 'S%' OR NOMBRE LIKE 'Z%')

-- VISTAS EN BASES DE DATOS
-- ES UNA INSTRUCCION SELECT ALMACENADA EN LA BD, NO ALMACENA
-- EL RESULTADO DEL SELECT

-- TAREA:
-- PARA QUE SIRVEN LAS VISTAS?
-- TIENE DOS UTILIDADES PRINCIPALES
-- 1. POR CONFIDENCIALIDAD DE LOS DATOS. RESTRICCION DE ACCESO
--    A LOS DATOS POR PARTE DE LOS USUARIOS.
-- 2. PARA EVITAR DIGITAR EL SELECT DE LA CONSULTA CADA VEZ
--    QUE VAMOS A EJECUTARLA.
CREATE VIEW VISTA1 AS
  SELECT NOMBRE, EDAD
  FROM ALCALDE     -- TABLA BASE
  WHERE SUELDO < 3000000
USE FERIAFLORES
SELECT * FROM VISTA1

SELECT SUELDO FROM ALCALDE
SELECT * FROM VISTA1 WHERE SUELDO > 3000000

UPDATE VISTA1
SET SUELDO = 6000000
WHERE NOMBRE = 'ANA BERNAL'

CREATE VIEW VISTA2 AS
  SELECT NOMBRE, EDAD
  FROM ALCALDE     -- TABLA BASE
  WHERE EDAD < 40

SELECT * FROM VISTA2

UPDATE VISTA2  -- A TRAVES DE LAS VISTAS YO PUEDO ACTUALIZAR
  SET EDAD = 55  -- LOS DATOS DE LA TABLA BASE
  WHERE NOMBRE = 'ANA BERNAL'


-- CLÁUSULA WITH CHECK OPTION: EVITA QUE DATOS QUE HAYAN EN EL RESULTADO DE
-- LA VISTA, INCUMPLAN CON LA CONDICION DEL WHERE (DE LA VISTA)
CREATE VIEW VISTA3 AS
  SELECT NOMBRE, EDAD
  FROM ALCALDE     -- TABLA BASE
  WHERE EDAD < 40
  WITH CHECK OPTION

SELECT * FROM VISTA3

UPDATE VISTA3
  SET EDAD = 36
  WHERE NOMBRE = 'CARLOS MESA'

UPDATE VISTA3
  SET EDAD = 51
  WHERE NOMBRE = 'JOSE ZAPATA'

CREATE VIEW VISTA4 AS
  SELECT CEDULA, NOMBRE, EDAD
  FROM ALCALDE     -- TABLA BASE
  WHERE EDAD < 40
  WITH CHECK OPTION

SELECT * FROM VISTA4

INSERT INTO VISTA4 VALUES (5600,'MARTIN ZAPATA',33)
INSERT INTO VISTA5 VALUES (6600,'CARLOS OSORIO',60)
SELECT * FROM ALCALDE

CREATE VIEW VISTA5 AS
  SELECT CEDULA, NOMBRE, EDAD
  FROM ALCALDE     -- TABLA BASE
  WHERE EDAD < 40

CREATE VIEW VISTA6 AS
  SELECT CEDULA, NOMBRE, EDAD, NOMBRE AS 'OTRONOMBRE'
  FROM ALCALDE   INNER JOIN OTRA TABLA  -- TABLA BASE
  WHERE EDAD < 40

SELECT * FROM VISTA6

  INSERT INTO VISTA5 VALUES (6600,'CARLOS OSORIO',60)

-- NUEVAS CLAUSULAS
-- EJECUTAR EL SIGUIENTE SELECT
SELECT * FROM ALCALDE

SELECT A.CEDULA, A.NOMBRE, A.EDAD
FROM ALCALDE A
WHERE A.EDAD >= ALL (SELECT A.EDAD FROM ALCALDE A)
-- ALL: PERMITE COMPARAR EL VALOR DE UN CAMPO, SI ES MAYOR/MAYOR O IGUAL
--   MENOR, ETC... QUE TODOS LOS VALORES QUE DEN COMO RESULTADO LA
-- SUBCONSULTA
-- OTRA MANERA DE SABER CUALES SON LOS ALCALDES "MAS VIEJITOS"
1. SELECT A.CEDULA, A.NOMBRE
    FROM ALCALDE A
	WHERE A.EDAD = (SELECT MAX(EDAD) FROM ALCALDE)
2. SELECT  TOP 1 A.CEDULA, A.NOMBRE
   FROM ALCALDE A
   ORDER BY A.EDAD DESC

SELECT * FROM ALCALDE

SELECT A.CEDULA, A.NOMBRE, A.EDAD
FROM ALCALDE A
WHERE A.EDAD > ANY (SELECT A.EDAD FROM ALCALDE A)
-- ANY: PERMITE COMPARAR EL VALOR DE UN CAMPO, SI ES MAYOR/MAYOR O IGUAL
--   MENOR, ETC... QUE AL MENOS UNO DE LOS VALORES QUE DEN COMO RESULTADO LA
-- SUBCONSULTA

-- ****************************************************************** --
-- **              PROGRAMACION DE BASES DE DATOS                  ** --
-- ****************************************************************** --
-- INTRODUCCION
-- LOS MOTORES DE BD TIENEN UN LENGUAJE DE PROGRAMACION INCORPORADO
--   
--    DBMS            LENGUAJE 4GL(LENGUAJES DE CUARTA GENERACION)
--    ORACLE                PL / SQL
--    INFORMIX              INFORMIX 4GL
--    DB2                   SQL
--    SQL SERVER            TRANSACT SQL

-- EN GENERAL, TODA APLICACION SE COMPONE DE DOS ELEMENTOS:
--    1. FRONT END: LA INTERFAZ CON LA QUE INTERACTUA EL USUARIO.
--    2. BACK END: MANIPULACION DE DATOS EN LA BD.

-- LOS LENGUAJES 4GL PERMITEN PROGRAMAR EL BACK END.

--  TIPOS DE PROGRAMAS:
-- 1. PROCEDIMIENTOS ALMACENADOS
-- 2. FUNCIONES DE USUARIO
-- 3. TRIGGERS (GATILLO / DISPARADORES / DESENCADENADORES)

-- CONCEPTOS GENERALES QUE SE PUEDEN USAR EN ESTOS PROGRAMAS
-- 1. CONTROL DE ERRORES
-- 2. MANEJO DE TRANSACCIONES Y ATOMICIDAD
-- 3. MANEJO DE CURSORES

-- ************************************************************* --
--               PROCEDIMIENTOS ALMACENADOS                   ** --
-- ************************************************************* --
USE FERIAFLORES

-- EJEMPLO No. 1
CREATE PROCEDURE EJEMPLO1 AS   -- CREACION DE PROCEDIMIENTO
  SELECT A.CEDULA, A.NOMBRE
  FROM ALCALDE A
  WHERE A.SUELDO > 3000000

-- EJECUTAR PROCEDIMIENTO
EXEC EJEMPLO1
-- DEFINICION: ES UN PROGRAMA ALMACENADO EN EL MOTOR DE LA BASE
--             DE DATOS.

-- EJEMPLO No. 2
-- PUEDE RECIBIR PARAMETROS
ALTER PROCEDURE EJEMPLO2 @SUEL MONEY AS
  SELECT A.CEDULA, A.NOMBRE
  FROM ALCALDE A
  WHERE A.SUELDO > @SUEL

EXEC EJEMPLO2 3000000

-- ****************************************************** --
--              FUNCION DE USUARIO                     ** --
-- ****************************************************** --

-- CREAR UNA FUNCION DE USUARIO
-- DEFINICION: PROGRAMA ALMACENADO EN LA BD QUE SIEMPRE
--     TIENE LA OBLIGACION DE RETORNAR UN VALOR
-- RETORNAR UN VALOR A QUIEN?
-- OBJETIVO DE LAS FUNCIONES ES QUE PUEDAN SER INVOCADAS
-- DESDE OTRO PROGRAMA O DESDE OTRA INSTRUCCION EXTERNA A
-- LA FUNCION.
CREATE FUNCTION CALCULAR_PROMEDIO() RETURNS FLOAT AS
BEGIN
  DECLARE @PROM FLOAT

  SELECT @PROM = AVG(A.SUELDO)
  FROM ALCALDE A

  RETURN @PROM
END

-- UNA FUNCION SE INVOCA, NO SE EJECUTA COMO EL PROCEDIMIENTO.
-- COMO SE INVOCA UNA FUNCION?
SELECT AVG(SUELDO) FROM ALCALDE

SELECT A.NOMBRE, dbo.CALCULAR_PROMEDIO()
FROM ALCALDE A

CREATE PROCEDURE LLAMAR_FUNCION AS
  DECLARE @PROMEDIO FLOAT
  SET @PROMEDIO = dbo.CALCULAR_PROMEDIO()
  PRINT @PROMEDIO

  EXEC LLAMAR_FUNCION

-- ************************************************** --
--                  TRIGGERS                       ** --
-- ************************************************** --
-- VAMOS A CREAR LA SIGUIENTE TABLA
CREATE TABLE PATROBORRADO
(NIT BIGINT,
NOMBRE VARCHAR(30),
FECHABOR DATE,
USUARIO VARCHAR(50))

-- CREAR UN TRIGGER
-- 1. LA LOGICA DEL TRIGGER SE EJECUTA AUTOMATICAMENTE
-- AUTOMATICAMENTE CUANDO? CUANDO SUCEDE EL EVENTO PARA
-- EL CUAL ESTA PROGRAMADO EJECUTARSE
-- CUALES SON LOS POSIBLES EVENTOS QUE DISPARAN
-- UN TRIGGER ???
-- AFTER INSERT - AFTER UPDATE - AFTER DELETE
-- TAREA:
-- HAY CUARTO EVENTO...... INSTEAD OF
CREATE TRIGGER TRIGGER1 ON PATROCINADOR AFTER DELETE AS
  DECLARE @NITPA BIGINT
  DECLARE @NOMPAT VARCHAR(30)

  -- EN LA LOGICA DE LOS TRIGGERS, EXISTEN 2 TABLAS
  -- TEMPORALES: INSERTED - DELETED
  -- TABLA DELETED: ACA ESTA LA INFORMACION BORRADA QUE
  --           DISPARO EL TRIGGER
  SELECT @NITPA = NIT, @NOMPAT = NOMBRE 
  FROM DELETED

  INSERT INTO PATROBORRADO VALUES
  (@NITPA, @NOMPAT, GETDATE(), USER)

  -- EXISTEN TRES POSIBLE EVENTOS QUE DISPARAN TRIGGERS
  -- AFTER INSERT, AFTER UPDATE, AFTER DELETE
  -- Y HAY DOS TABLAS TEMPORALES:
  -- INSERTED - DELETED
  -- POR QUE NO EXISTE UNA TABLA TEMPORAL LLAMADA UPDATED?
  -- EN UN TRIGGER AFTER UPDATE, SE GUARDA EN LA TABLA DELETED
  -- EL REGISTRO ORIGINAL, ANTES DE ACTUALIZARSE. y EN LA 
  -- TABLA INSERTED GUARDA EL REGISTRO ACTUALIZADO.

DELETE FROM PATROCINADOR WHERE NIT=160

SELECT * FROM PATROBORRADO
-- PRIMERA UTILIDAD DE ESTE TRIGGER:
-- HACER UNA COPIA DE LOS DATOS BORRADOS, POR SI NECESITO 
-- RECUPERARLOS DESPUES.
-- AHORCADITO PARA DESCIFRAR LA PALABRA QUE DESCRIBE LA
-- SEGUNDA UTILIDAD DE ESTE TRIGGER:

--  A U D I T O R I A    D E    B O R R A D O

USE FERIAFLORES

-- IMPLEMENTAR CONTROL DE ERRORES
ALTER PROCEDURE ERRORES @CED BIGINT, @ED SMALLINT AS
BEGIN TRY
  INSERT INTO ALCALDE VALUES
     (@CED,'LAURA TAMAYO',@ED, NULL, 3000000)
  PRINT 'GRABACION DE ALCALDE EXITOSA'
END TRY
BEGIN CATCH
  PRINT 'HUBO UN ERROR EN LA GRABACION DEL ALCALDE'
  PRINT ERROR_MESSAGE()
END CATCH

EXEC ERRORES 6005, 30
EXEC ERRORES 6006, 130

-- IMPLEMENTAR TRANSACCIONES / ATOMICIDAD
-- CREAR UN PROCEDIMIENTO ALMACENADO SIN ATOMICIDAD
DROP PROCEDURE SINATOMICIDAD

ALTER PROCEDURE SINATOMICIDAD @CED BIGINT, @ED SMALLINT AS
  UPDATE CIUDAD SET NUMHABITANTES = 800000 WHERE CODIGO = 90
  INSERT INTO ALCALDE VALUES
     (@CED,'CARLOS DUARTE',@ED, NULL, 5000000)

-- IMAGINAR QUE ESTO FUERA UNA TRANSFERENCIA DE FONDOS DE UNA
-- CUENTA BANCARIA A OTRA
--   A = A - 1000000
--   B = B + 1000000

EXEC SINATOMICIDAD 5201, 33
EXEC SINATOMICIDAD 5204, 160  -- EJECUTO EL UPDATE PERO NO EL INSERT
SELECT * FROM CIUDAD
SELECT * FROM ALCALDE

-- COMO IMPLEMENTAR ATOMICIDAD EN UN PROCEDIMIENTO
CREATE PROCEDURE CONATOMICIDAD @CED BIGINT, @ED SMALLINT AS
BEGIN TRANSACTION
BEGIN TRY
  UPDATE CIUDAD SET NUMHABITANTES = 900000 WHERE CODIGO = 90
  INSERT INTO ALCALDE VALUES
     (@CED,'CARLOS DUARTE',@ED, NULL, 5000000)
  COMMIT TRANSACTION  -- CONFIRMAR QUE LA TX TERMINO BIEN Y QUE POR LO
					 -- TANTO, DEBE VERSE REFLEJADO EN LA BASE DE DATOS.
END TRY
BEGIN CATCH
  ROLLBACK TRANSACTION  -- REVERSAR LO HECHO HASTA EL MOMENTO DEL FALLO
  PRINT 'HUBO UN ERROR EN EL PROCESO'
  PRINT ERROR_MESSAGE()
END CATCH

EXEC CONATOMICIDAD 6920, 122

EXEC CONATOMICIDAD 6920, 60

-- CONCEPTO DE CURSOR
-- DEFINICION: ESPACIO DE MEMORIA RAM DONDE SE ALMACENA EL RESULTADO DE UN SELECT
CREATE PROCEDURE CONCURSOR AS
  DECLARE @COD BIGINT
  DECLARE @NOM VARCHAR(30)
  DECLARE @NH BIGINT
  DECLARE CURSOR1 CURSOR FOR  -- DECLARACION DEL CURSOR: SIEMPRE TIENE ASOCIADO UN SELECT
    SELECT C.CODIGO, C.NOMBRE, C.NUMHABITANTES
	FROM CIUDAD C
  OPEN CURSOR1  -- ABRIR / ACTIVAR EL CURSOR...SE EJECUTA EL SELECT Y SE LLENA EL CURSOR
  FETCH CURSOR1 INTO @COD, @NOM, @NH  -- LEER PRIMER REGISTRO DEL CURSOR
  WHILE (@@FETCH_STATUS = 0)  -- DOS ARROBAS: VARIABLES INTERNAS DE SQL SERVER
  BEGIN
    PRINT 'CODIGO DE CIUDAD: ' + STR(@COD)
	PRINT 'NOMBRE DE CIUDAD: ' + @NOM
	PRINT 'NUMERO DE HABITANTES: ' + STR(@NH)
	FETCH CURSOR1 INTO @COD, @NOM, @NH  -- LEER EL SIGUIENTE REGISTRO DEL CURSOR
  END
  CLOSE CURSOR1  -- CERRAR / DESACTIVAR EL CURSOR
  DEALLOCATE CURSOR1 -- BORRAMOS FISICAMENTE EL CURSOR -- LIBERAR MEMORIA RAM

EXEC CONCURSOR

-- ****************************************************************************** --
-- **                         EJERCICIO No. 1                                  ** --
-- ****************************************************************************** --
-- LA GERENCIA DEL DESFILE DE AUTOS CLÁSICOS Y ANTIGUOS NECESITA SABER CUÁNTO     --
-- DEBE PAGAR CADA VEHÍCULO POR TENER DERECHO A DESFILAR EN LA VERSIÓN DEL AÑO    --
-- ENTRANTE.                                                                      --
-- PARA SABER CUANTO DEBE PAGAR UN VEHICULO, COMO DERECHO DE INSCRIPCION, SE      --
-- BASA EN EL MODELO Y EL PRECIO DEL VEHICULO, DE LA SIGUIENTE FORMA:
--     ** SI EL VEHICULO ES MODELO ANTERIOR A 1960 Y SU PRECIO ESTÁ ENTRE
--        3000000 Y 9000000, DEBE PAGAR UNA INSCRIPCION DEL 15 % DEL PRECIO DEL
--        VEHICULO.
--     ** SI EL VEHICULO ES MODELO ENTRE 1960 Y 1970, Y SU PRECIO ESTÁ ENTRE 
--        9000000 Y 12000000, DEBE PAGAR UN 18 % DEL PRECIO DEL CARRO.
--     ** EN CUALQUIER OTRO CASO, DEBE PAGAR EL 20 % DEL PRECIO DEL VEHICULO.
-- HACER UN PROGRAMA QUE PERMITA HACER EL CALCULO PARA CADA UNO DE LOS VEHICULOS
-- Y GRABAR, EN UNA TABLA APARTE, DICHO VALOR.
USE FERIAFLORES
CREATE TABLE INSCRIPCION
(PLACAVEH VARCHAR(6) NOT NULL,
VALORPAGAR MONEY)

CREATE PROCEDURE CALCULAR_INSCRIPCION AS
BEGIN TRANSACTION
BEGIN TRY
  DECLARE @PLACAVEH VARCHAR(6)
  DECLARE @MODELOVEH SMALLINT
  DECLARE @PRECIOVEH MONEY
  DECLARE @VLRINSCRIPCION MONEY
  DECLARE CURSOR5 CURSOR FOR
    SELECT V.PLACA, V.MODELO, V.PRECIO
	FROM VEHICULO V
  OPEN CURSOR5
  FETCH CURSOR5 INTO @PLACAVEH, @MODELOVEH, @PRECIOVEH
  WHILE (@@FETCH_STATUS = 0)
  BEGIN
    SET @VLRINSCRIPCION = dbo.VALIDAR_CONDICIONES(@MODELOVEH, @PRECIOVEH)
	INSERT INTO INSCRIPCION VALUES
	  (@PLACAVEH, @VLRINSCRIPCION)
	FETCH CURSOR5 INTO @PLACAVEH, @MODELOVEH, @PRECIOVEH
  END
  CLOSE CURSOR5
  DEALLOCATE CURSOR5
  COMMIT TRANSACTION
  PRINT 'LOS VEHICULOS HAN SIDO EXITOSAMENTE PROCESADOS'
END TRY
BEGIN CATCH
  ROLLBACK TRANSACTION
  PRINT 'HUBO UN ERROR EN EL PROCESO'
END CATCH

EXEC CALCULAR_INSCRIPCION

SELECT * FROM INSCRIPCION

DELETE FROM INSCRIPCION
SELECT * FROM VEHICULO

IF (TAL COSA)
BEGIN
  INSTR 1
  INSTR 2
  INSTR 3
END
ELSE
BEGIN
  INSTR 4
  INSTR 5
END


CREATE FUNCTION VALIDAR_CONDICIONES(@MV SMALLINT, @PV MONEY) RETURNS MONEY AS
BEGIN
  DECLARE @VALORINS MONEY
  IF (@MV < 1960) AND (@PV >= 3000000 AND @PV <= 9000000)
    SET @VALORINS = @PV * 0.15
  ELSE
    IF (@MV >= 1960 AND @MV <= 1970) AND (@PV >= 9000000 AND @PV <= 12000000)
	  SET @VALORINS = @PV * 0.18
	ELSE
	  SET @VALORINS = @PV * 0.20
  RETURN @VALORINS
END

CREATE PROCEDURE CALCULAR_PAGO AS
DECLARE @PLACA VARCHAR(6)
DECLARE @MODELO SMALLINT
DECLARE @PRECIO MONEY
DECLARE @PRECIO_FINAL MONEY
DECLARE VEHICULO CURSOR FOR
SELECT V.PLACA, V.PRECIO, V.MODELO
FROM VEHICULO V
OPEN VEHICULO
FETCH VEHICULO INTO @PLACA, @PRECIO, @MODELO
WHILE (@@FETCH_STATUS = 0)
BEGIN
IF (@MODELO < 1960 AND @PRECIO BETWEEN 3000000 AND 9000000)
BEGIN
SET @PRECIO_FINAL = @PRECIO * 0.15
END
IF ((@MODELO BETWEEN 1960 AND 1970) AND (@PRECIO BETWEEN 9000000 AND 12000000))
BEGIN
SET @PRECIO_FINAL = @PRECIO * 0.18
END
ELSE
BEGIN
SET @PRECIO_FINAL = @PRECIO * 0.20
END
PRINT 'El vehiculo con placa: ' + @PLACA + ' debe de pagar: ' + STR(@PRECIO_FINAL)
FETCH VEHICULO INTO @PLACA, @PRECIO, @MODELO
END
CLOSE VEHICULO
DEALLOCATE VEHICULO









-- ***************************************************************************** --
-- **                              EJERCICIO No. 2                            ** --
-- ***************************************************************************** --
-- LA GERENCIA DEL DESFILE ESTÁ MUY INTERESADA EN HACER UNA SELECCIÓN DE      ** --
-- PATROCINADORES QUE RESPONDAN ECONOMICAMENTE ANTE LOS PROPIETARIOS DE LOS   ** --
-- VEHICULOS.
-- PARA TAL FIN, EN LA TABLA PATROCINADOR, TIENE LA LISTA DE PATROCiNADORES   ** --
-- ASPIRANTES PARA EL AÑO ENTRANTE.
-- PARA HACER LA SELECCION, SE BASA EN QUE EL PATROCINADOR CUMPLA MÍNIMO UNO  ** --
-- DE LOS CRITERIOS SIGUIENTES:
--    ** SI SU AÑO DE FUNDACION ES ANTERIOR A 1950 Y HA PATROCINADO VEHICULOS ** --
--       QUE HAYAN DESFILADO EN 3 O MAS EDICIONES.
--    ** SI SU AÑO DE FUNDACION ES POSTERIOR A 1970 Y HA PATROCINADO VEHICULOS** --
--       QUE PROVENGAN DE CIUDADES DE MÁS DE 1500000 DE HABITANTES.
-- EN LA TABLA PATROCINADOR, SE DEBE DEJAR CONSTANCIA DE SI ES UN PATROCINADOR** --
-- ESCOGIDO O NO.


-- VAMOS A HACER UN PROGRAMA QUE PERMITA GRABAR UNA NUEVA CIUDAD EN LA BD.
USE FERIAFLORES
ALTER PROCEDURE GRABAR_CIUDAD @CODC SMALLINT, @NOMC VARCHAR(30),
                               @NHAB BIGINT, @FECHAF VARCHAR(10) AS
BEGIN TRANSACTION
BEGIN TRY
  IF EXISTS(SELECT * FROM CIUDAD WHERE CODIGO = @CODC)
    PRINT 'LA CIUDAD QUE ESTA TRATANDO DE GRABAR YA EXISTE'
  ELSE
    BEGIN
      INSERT INTO CIUDAD VALUES (@CODC, @NOMC, @NHAB, @FECHAF)
	  PRINT 'LA CIUDAD HA SIDO EXITOSAMENTE GRABADA'
	END
  COMMIT TRANSACTION
END TRY
BEGIN CATCH
  ROLLBACK TRANSACTION
  PRINT 'HUBO UN ERROR EN EL PROCESO'
  PRINT ERROR_MESSAGE()
END CATCH

SELECT * FROM CIUDAD

EXEC GRABAR_CIUDAD 101,'LETICIA',800000,'20/09/1715'

SELECT * FROM CIUDAD

ALTER PROCEDURE GRABAR_PATROCINADOR @NITP BIGINT,@NOMP VARCHAR(30), 
                                    @AÑOF SMALLINT,
                                     @PLACAV VARCHAR(6) AS
BEGIN TRANSACTION
BEGIN TRY
  IF EXISTS (SELECT * FROM PATROCINADOR WHERE NIT=@NITP)
    PRINT 'PATROCINADOR YA EXISTENTE'
  ELSE
  BEGIN
    IF EXISTS (SELECT * FROM VEHICULO WHERE PLACA=@PLACAV)
    BEGIN
      INSERT INTO PATROCINADOR VALUES (@NOMP, @AÑOF, @PLACAV)
      PRINT 'INSERCIÓN EXITOSA'
    END
    ELSE
      PRINT 'VEHÍCULO NO EXISTENTE'
   END
  COMMIT TRANSACTION
END TRY
BEGIN CATCH
  ROLLBACK TRANSACTION
  PRINT 'HUBO UN ERROR EN EL PROCESO'
  PRINT ERROR_MESSAGE()
END CATCH

EXEC GRABAR_PATROCINADOR 'CLARO',1960,'KIL650'

SELECT * FROM PATROCINADOR

-- HACER UN PROCEDIMIENTO ALMACENADO PARA BORRAR UN PATROCINADOR

-- HACER UN PROCEDIMIENTO ALMACENADO PARA BORRAR UNA CIUDAD

-- HACER UN PROCEDIMIENTO PARA ACTUALIZAR LOS DATOS DE UN PATROCINADOR.

-- ******************************************************************************** --
-- **                          CLASE NOVIEMBRE 2                                 ** --
-- ******************************************************************************** --

-- 1. CLAUSULA UNION VS UNION ALL
-- 2. FUNCIONES QUE DEVUELVEN TABLAS
-- 3. BORRADO Y ACTUALIZACION EN CASCADA
-- 4. CLAUSULA CASE EN EL SELECT
-- 5. BACKUP Y RESTORE

-- BORRADO Y ACTUALIZACION EN CASCADA

USE FERIAFLORES
SELECT * FROM ALCALDE
SELECT * FROM PATROCINADOR

INSERT INTO PATROCINADOR VALUES ('VERONICA ZEA',1985, NULL)

SELECT A.NOMBRE, 'ALCALDE'
FROM ALCALDE A
UNION ALL
SELECT P.NOMBRE, 'PATROCINADOR'
FROM PATROCINADOR P

ALTER TABLE VEHICULO ADD FOREIGN KEY(CODCIUDAD) REFERENCES CIUDAD(CODIGO)
ON DELETE CASCADE

INSERT INTO CIUDAD VALUES (2506,'RIOHACHA',200000,NULL)
INSERT INTO VEHICULO VALUES ('KKK600','TOYOTA',2000,6000000,2506)

DELETE FROM CIUDAD WHERE CODIGO = 2506

SELECT * FROM CIUDAD

SELECT * FROM VEHICULO

-- CLAUSULA CASE EN UN SELECT
USE FERIAFLORES
DROP TABLE EMPLEADO
CREATE TABLE EMPLEADO
(CEDULA BIGINT PRIMARY KEY,
NOMBRE VARCHAR(30) NOT NULL,
CATEGORIA SMALLINT)

INSERT INTO EMPLEADO VALUES (10, 'CARLOS CARDONA',1)
INSERT INTO EMPLEADO VALUES (20, 'OLGA GALLEGO',1)
INSERT INTO EMPLEADO VALUES (30, 'TATIANA ARIAS',2)
INSERT INTO EMPLEADO VALUES (40, 'PEDRO LOPEZ',3)
INSERT INTO EMPLEADO VALUES (50, 'CAROLINA MUNERA',3)
INSERT INTO EMPLEADO VALUES (60, 'DANIELA POSADA',4)

SELECT * FROM EMPLEADO

SELECT E.CEDULA, E.NOMBRE,
    CASE E.CATEGORIA
	  WHEN 1 THEN 'NIVEL OPERATIVO'
	  WHEN 2 THEN 'NIVEL ADMINISTRATIVO'
	  WHEN 3 THEN 'NIVEL GERENCIAL'
	  ELSE 'DESCONOCIDO'
	END
FROM EMPLEADO E

UPDATE EMPLEADO
  SET CATEGORIA = CASE CATEGORIA
     WHEN 1 THEN 7
	 WHEN 2 THEN 8
	 WHEN 3 THEN 9
	 ELSE 0
	END

SELECT * FROM EMPLEADO

-- UNION ELIMINA REGISTROS DUPLICADOS
-- UNION ALL IMPRIME TODOS LOS REGISTROS, INCLUYENDO LOS DUPLICADOS.

-- *************************************************************************** --
-- **                   CLASE NOVIEMBRE 9                                   ** --
-- *************************************************************************** --
-- COMO HACER UN RESTORE DE UN BACKUP?

-- FUNCIONES DE TIPO NUMERICO

-- 1. ABS             2. CEILING / FLOOR                 3. %
-- 4. POWER           5. ROUND                           6. RAND
-- 7. SIGN            8. SQRT

-- FUNCIONES DE TIPO STRING / VARCHAR

-- 1. ASCII           2. CHARINDEX                      3. CONCAT
-- 4. CONCAT_WS       5. FORMAT                         6. LEFT / RIGHT
-- 7. LEN             8. LTRIM / RTRIM / TRIM           9. PATINDEX
-- 10. REPLACE       11. REPLICATE                     12. REVERSE
-- 13. SPACE         14. STRING_SPLIT                  15. STUFF
-- 16. TRANSLATE

-- FUNCIONES DE TIPO FECHA

-- 1. SYSDATETIME     2. SYSDATETIMEOFFSET              3. GETDATE
-- 4. DATEFROMPARTS   5. DATEDIFF                       6. DATEADD
-- 7. EOMONTH

-- ************************************************************************* --
-- **                 FUNCIONES NUMERICAS                                 ** --
-- ************************************************************************* --
-- 1. ABS ... VALOR ABSOLUTO DE UN NUMERO
USE FERIAFLORES3
SELECT ABS(-1000)

-- 2. CEILING / FLOOR....ENTERO MAS CERCANO POR ENCIMA / ENTERO MAS CERCANO POR DEBAJO
SELECT CEILING(25.75)
SELECT CEILING(25.000001)
SELECT FLOOR(25.75)
SELECT FLOOR(25.000001)
-- 3. %: MODULO ....RESIDUO DE UNA DIVISION
SELECT 5 % 3
SELECT 13 % 4
SELECT 22 % 5

-- 4. POWER: ELEVA EL PRIMER NUMERO A LA POTENCIA DEL SEGUNDO
SELECT POWER(6,2)

-- 5. RAND: GENERA NUMEROS ALEATORIOS, POR DEFECTO, ENTRE 0 Y 1
SELECT RAND()*(10-5)+5

-- 6. ROUND: REDONDEAR UN NUMERO, A UNA CANTIDAD DETERMINADA DE DECIMALES
SELECT ROUND(5.1,0)

SELECT ROUND(29.635,2)

SELECT ROUND(29.624,2)

-- 7. SIGN: SABER EL SIGNO DE UN NUMERO
SELECT SIGN(2500)
SELECT SIGN(-2500)
SELECT SIGN(0)

-- 8. SQRT: RAIZ CUADRADA
SELECT SQRT(25)
SELECT SQRT(36)
SELECT SQRT(41)

-- *********************************************************************** --
-- **                    FUNCIONES TIPO STRING                          ** --
-- *********************************************************************** --
-- 1. ASCII: IMPRIME EL CODIGO ASCII DE UN CARACTER ESPECIFICO
SELECT ASCII('\')
SELECT ASCII('á')

-- 2. CHARINDEX: RETORNA LA POSICION INICIAL DE UN SUBSTRING DENTRO DE UN STRING
SELECT CHARINDEX('T','BASE DE DATOS')
SELECT CHARINDEX('Z','BASE DE DATOS')

-- 3. CONCAT: CONCATENA DOS O MAS STRINGS
SELECT CONCAT(A.NOMBRE, STR(A.EDAD), STR(A.SUELDO))
FROM ALCALDE A

-- 4. CONCAT_WS: CONCATENA DOS O MAS STRINGS, SEPARANDOLOS CON UN CARACTER
--               DE SEPARADOR
SELECT CONCAT_WS('/', 'www', 'W3Schools', 'com')

-- 5. FORMAT
SELECT FORMAT(123456789, '##-##-#####')
-- 6. LEFT / RIGHT: SELECCIONA LOS PRIMEROS N CARACTERES DEL STRING, EMPEZANDO POR
--            LA IZQUIERDA / LA DERECHA

SELECT LEFT('SQL Tutorial', 5)
SELECT RIGHT('SQL Tutorial', 4)

-- 7. LEN: LONGITUD DE UN STRING
SELECT LEN('ABCDE')
SELECT A.NOMBRE, LEN(A.NOMBRE)
FROM ALCALDE A

-- 8. LTRIM / RTRIM - TRIM: ELIMINA ESPACIOS EN BLANCO A LA DERECHA E IZQUIERDA
--      DEL STRING
SELECT 'LUISA BEDOYA                    .', RTRIM('LUISA BEDOYA                   ')
SELECT '      LUISA BEDOYA       ', TRIM('      LUISA BEDOYA       ')
-- 9. PATINDEX: APLICA IGUAL QUE EL CHARINDEX PERO PARA SUBSTRINGS DE MAS DE UN
--       CARACTER.
SELECT PATINDEX('%schoolG%', 'W3Schools.com')
-- 10. REPLACE: REEMPLAZA UN CARACTER POR OTRO EN UN SUBSTRING
SELECT REPLACE(A.NOMBRE,'S','Z')
FROM ALCALDE A

-- 11. REPLICATE: REPITE UN STRING UN NUMERO DE VECES
SELECT REPLICATE(A.NOMBRE, 3)
FROM ALCALDE A
-- 12. REVERSE: IMPRIME UN STRING DE DERECHA A IZQUIERDA

SELECT REVERSE(A.NOMBRE)
FROM ALCALDE A
-- 13. SPACE: IMPRIME N ESPACIOS EN BLANCO

SELECT A.NOMBRE + SPACE(25) + STR(A.SUELDO)
FROM ALCALDE A

-- 14. STRING_SPLIT: ES UNA FUNCION QUE DEVUELVE UNA TABLA DE UN SOLO CAMPO.
--      COGE EL STRING Y CADA QUE ENCUENTRA EL SEPARADOR, AHI CORTA EL STRING
--      EN REGISTROS O RENGLONES DIFERENTES.

SELECT VALUE
FROM STRING_SPLIT('AAA/BBBBBBB/CCCCCC/D','/')

-- 15. STUFF: BORRA UN SUBSTRING EMPEZANDO DESDE UNA POSICION, TANTOS CARACTERES
--     Y A PARTIR DE LA POSICION INICIAL INSERTA EL NUEVO SUBSTRING

SELECT STUFF('SQL Tutorial', 1, 3, 'HTML')

-- 16. TRANSLATE

SELECT TRANSLATE('CAROLINA MARIN','ARI','ETO')

-- ********************************************************************** --
-- **                      FUNCIONES TIPO FECHA                        ** --
-- ********************************************************************** --

-- 1. SYSDATETIME
-- 2. SYSDATETIMEOFFSET
-- 3. GETDATE
-- 4. DATEFROMPARTS
-- 5. DATEDIFF
-- 6. DATEADD
-- 7. EOMONTH

-- ************************************************************************** --
-- **           OPTIMIZACIÓN DE CONSULTAS - ALGEBRA RELACIONAL             ** --
-- ************************************************************************** --

-- VER DOCUMENTO DE OPTIMIZACION DE CONSULTAS, USANDO ALBEBRA RELACIONAL.

-- ************************************************************************** --
-- **                       CLASE NOVIEMBRE 11                             ** --
-- ************************************************************************** --

USE FERIAFLORES
GO

-- ************************************************************************** --
-- **                 CALCULO DE ATRIBUTOS DERIVADOS                       ** --
-- ************************************************************************** --

CREATE TABLE PROPIETARIO
(CEDULA BIGINT PRIMARY KEY,
NOMBRE VARCHAR(30) NOT NULL,
EDAD SMALLINT,
VALORPATRIMONIO MONEY,
VALORPAGAR AS (VALORPATRIMONIO * 0.11))  -- ATRIBUTO DERIVADO / CALCULADO

SELECT * FROM PROPIETARIO

INSERT INTO PROPIETARIO VALUES (1000,'PAULA BETANCUR',45,1000000)

-- HACERLO POR MODO GRÁFICO

-- CALCULAR LA EDAD, CON BASE EN LA FECHA DE NACIMIENTO

ALTER TABLE ALCALDE DROP COLUMN EDAD

ALTER TABLE ALCALDE 
  ADD EDAD AS (DATEDIFF(year, FECHANAC, GETDATE()))

INSERT INTO ALCALDE VALUES (1300,'CLAUDIA LOPEZ','1985-03-25',5600000)

SELECT * FROM ALCALDE

-- HACERLO POR MODO GRÁFICO

-- ************************************************************************ --
-- **               COMPARACIÓN CON VALORES NULOS                        ** --
-- ************************************************************************ --

-- CONSULTAR NOMBRES DE ALCALDES CUYA EDAD ES NULA
SELECT A.NOMBRE
FROM ALCALDE A
WHERE A.EDAD = NULL   -- CUAL ES EL RESULTADO?

SELECT A.NOMBRE
FROM ALCALDE A
WHERE A.EDAD IS NULL     -- CLÁUSULA IS

SELECT A.NOMBRE
FROM ALCALDE A
WHERE A.EDAD IS NOT NULL -- CLÁUSULA IS NOT

-- ************************************************************************ --
-- **                   CLÁUSULA TRUNCATE                                ** --
-- ************************************************************************ --

INSERT INTO PROPIETARIO VALUES (2000,'JORGE BEDOYA',54,2000000)
SELECT * FROM PROPIETARIO

TRUNCATE TABLE PROPIETARIO

-- BORRA TODOS LAS TUPLAS / REGISTROS DE UNA TABLA

-- DIFERENCIA ENTRE TRUNCATE Y DELETE?
-- DELETE: POR CADA TUPLA BORRADA, GRABA EN EL LOG..... BLOQUEA CADA UNO DE LOS
--              REGISTROS A BORRAR.
-- TRUNCATE: SOLO GRABA EN EL LOG INFORMACIÓN REFERENTE A LA PÁGINA DE DONDE SE
--           BORRÓ........... BLOQUEA TODA LA TABLA.

-- ************************************************************************ --
-- **                       ÍNDICES                                      ** --
-- ************************************************************************ --

-- QUÉ ES UN ÍNDICE? ES UNA ESTRUCTURA ASOCIADA A LOS DATOS DE UNA TABLA,
--        POR MEDIO DE UN CAMPO DE DICHA TABLA
-- PARA QUÉ SIRVEN? PARA QUE LAS CONSULTAS SOBRE ESA TABLA SEAN MAS RAPIDAS
-- DESVENTAJAS DE LOS ÍNDICES.....LAS OPERACIONES DE ACTUALIZACION
--    (INSERCION, ACTUALIZACION Y BORRADO) MERMAN SU RENDIMIENTO

-- ÍNDICES POR CLAVE PRIMARIA

-- CREAR UN ÍNDICE
USE FERIAFLORES
CREATE INDEX INDICE_SUELDO ON ALCALDE(SUELDO)

SELECT * FROM ALCALDE

-- PERMITE SUELDOS DUPLICADOS

-- CREAR UN ÍNDICE ÚNICO: ME ASEGURA VALORES UNICOS / DISTINTOS PARA ESE CAMPO
CREATE UNIQUE INDEX INDICE_FECHANAC ON ALCALDE(FECHANAC)

CREATE UNIQUE INDEX INDICE_NOMBRE ON ALCALDE(NOMBRE)
UPDATE ALCALDE SET NOMBRE = 'CARLOS MEJIA' WHERE CEDULA = 6920

INSERT INTO ALCALDE VALUES (6298,'CLAUDIA LOPEZ', NULL, 2600000)

-- SACA ERROR PORQUE HAY DOS ALCALDES QUE TIENEN LA MISMA FECHA DE NACIMIENTO.

UPDATE ALCALDE SET FECHANAC = '1941-03-03' WHERE CEDULA = 1210

-- VOLVER A CREAR EL ÍNDICE ÚNICO Y LUEGO TRATAR DE INSERTAR UN NUEVO ALCALDE
-- CON FECHA DE NACIMIENTO '1941-03-03'...QUÉ PASA?

CREATE UNIQUE INDEX INDICE_NOMBRE ON ALCALDE(NOMBRE)

-- TRATAR DE GRABAR UN NUEVO ALCALDE CON EL MISMO NOMBRE DE OTRO QUE YA ESTÉ 
-- GRABADO....QUÉ SUCEDE?

-- BORRAR ÍNDICES

DROP INDEX ALCALDE.INDICE_NOMBRE

-- ************************************************************************ --
-- **                   MANEJO DE CONTRASEÑAS                            ** --
-- **                 ENCRIPTAR / DESENCRIPTAR                           ** --
-- ************************************************************************ --

CREATE TABLE USUARIOS
(USUARIO VARCHAR(30) PRIMARY KEY,
CONTRASEÑA VARBINARY(5000))

-- ENCRIPTAR

INSERT INTO USUARIOS VALUES ('jbedoyar',ENCRYPTBYPASSPHRASE('sarita','santy2002'))

-- ENCRYPTBYPASSPHRASE (clave para desencriptar, contraseña)

SELECT * FROM USUARIOS

-- DESENCRIPTAR

SELECT USUARIO, DECRYPTBYPASSPHRASE('sarita2015',CONTRASEÑA)
FROM USUARIOS

-- QUÉ SUCEDE?

SELECT USUARIO, CONVERT(VARCHAR,DECRYPTBYPASSPHRASE('sarita',CONTRASEÑA))
FROM USUARIOS

-- POR QUE, AUN SALE LA CONTRASEÑA DE TIPO BINARIO?

SELECT USUARIO, CONVERT(VARCHAR,DECRYPTBYPASSPHRASE('sarita',CONTRASEÑA))
FROM USUARIOS

-- **************************************************************************** --
-- **                    CLASE NOVIEMBRE 16                                  ** --
-- **************************************************************************** --
-- CLAUSULAS UNIQUE, DISCTICTROW Y DISTINCT
-- UNIQUE ES DE ORACLE
-- DISTINCTROW ES DE ACCESS
-- DISTINCT ES SQL ESTANDAR

USE FERIAFLORES
SELECT C.NOMBRE, V.PLACA, V.MARCA
FROM CIUDAD C INNER JOIN VEHICULO V
ON C.CODIGO = V.CODCIUDAD

SELECT DISTINCT NOMBRE
FROM CIUDAD C INNER JOIN VEHICULO V
ON C.CODIGO = V.CODCIUDAD

--PONER, EN UN CAMPO, UN VALOR POR DEFAULT

CREATE TABLE ASISTENTE
(CEDULA BIGINT PRIMARY KEY,
NOMBRE VARCHAR(30) NOT NULL,
EDAD SMALLINT DEFAULT 0)   -- CLAUSULA DEFAULT

INSERT INTO ASISTENTE VALUES (1000, 'LORENA GALLEGO', 33)
SELECT * FROM ASISTENTE
INSERT INTO ASISTENTE VALUES (2000, 'ANA SOFIA TORO', NULL)
SELECT * FROM ASISTENTE
INSERT INTO ASISTENTE(CEDULA, NOMBRE) VALUES (3000, 'MARIO LOPEZ')
SELECT * FROM ASISTENTE

-- HACERLO POR MODO GRAFICO

-- INSTRUCCION CAST / CONVERT
-- RECUEREN QUE EN LA TABLA CIUDAD ESTA LA FECHA DE FUNDACION, PERO ESTÁ
-- DEFINIDA VARCHAR(10)
-- CAST
SELECT * FROM CIUDAD

SELECT C.NOMBRE, C.FECHAFUN,
       DATEDIFF(year,CAST(C.FECHAFUN AS DATE), GETDATE())
FROM CIUDAD C

-- CONVERT: SE USA, SOBRETODO, PARA FORMATEAR FECHAS.
SELECT CONVERT(VARCHAR(19),GETDATE())
SELECT CONVERT(VARCHAR(10),GETDATE(),10)
SELECT CONVERT(VARCHAR(10),GETDATE(),110)
SELECT CONVERT(VARCHAR(11),GETDATE(),6)
SELECT CONVERT(VARCHAR(11),GETDATE(),106)
SELECT CONVERT(VARCHAR(30),GETDATE(),113)

-- **************************************************************************** --
-- **                    CLASE NOVIEMBRE 18                                  ** --
-- **************************************************************************** --
-- OTROS COMODINES DEL LIKE

SELECT * FROM EMPLEADO

-- COMODÍN _: UN SOLO CARACTER, CUALQUIERA QUE SEA

SELECT E.NOMBRE, LEN(E.NOMBRE)
FROM EMPLEADO E
WHERE E.NOMBRE LIKE 'C____________'   -- 12 GUIONES BAJOS

SELECT E.NOMBRE, LEN(E.NOMBRE)
FROM EMPLEADO E
WHERE E.NOMBRE LIKE 'C_____________'  -- EMPIECE POR C Y ESTE SEGUIDO DE 
                                      -- 13 CARACTERES (_: UN CARACTER)

SELECT E.NOMBRE
FROM EMPLEADO E
WHERE E.NOMBRE LIKE '___O%'   -- QUE HACE?

-- COMODÍN [ ]
SELECT E.NOMBRE
FROM EMPLEADO E
WHERE E.NOMBRE LIKE '[A-E]%' -- EMPLEADOS CUYA PRIMERA LETRA DEL NOMBRE
                             -- SEA A, B, C, D o E

SELECT E.NOMBRE
FROM EMPLEADO E
WHERE E.NOMBRE LIKE '__[R-U]%'		-- QUE HACE?

SELECT E.NOMBRE
FROM EMPLEADO E
WHERE E.NOMBRE LIKE '[^A-E]%'   -- NEGACION

-- CARACTER DE ESCAPE
UPDATE EMPLEADO SET NOMBRE = 'DANIELA%POSADA' WHERE CEDULA = 60

SELECT * FROM EMPLEADO

-- CONSULTAR LOS EMPLEADOS EN CUYO NOMBRE EXISTE EL CARACTER %

SELECT E.NOMBRE
FROM EMPLEADO E
WHERE E.NOMBRE LIKE '%%%' 

SELECT E.NOMBRE
FROM EMPLEADO E
WHERE E.NOMBRE LIKE '%#%%' ESCAPE '#'

-- COMO INSERTAR DATOS EN UNA TABLA, A PARTIR DE LOS DATOS DE OTRA TABLA
-- DOS MANERAS:

-- 1. PREVIAMENTE HAY QUE CREAR LA TABLA DESTINO
DROP TABLE CIUDAD1

CREATE TABLE CIUDAD1
(CODCIUDAD INT PRIMARY KEY,
NOMBRECIU VARCHAR(30),
NUMHAB BIGINT,
AREA  BIGINT)

INSERT INTO CIUDAD1 (CODCIUDAD, NOMBRECIU, NUMHAB)
  SELECT CODIGO, NOMBRE, NUMHABITANTES FROM CIUDAD

SELECT * FROM CIUDAD1
SELECT * FROM CIUDAD

-- 2. NO HAY QUE CREAR PREVIAMENTE LA TABLA DESTINO
DROP TABLE CIUDAD3

SELECT CODIGO, NOMBRE, NUMHABITANTES
INTO CIUDAD4
FROM CIUDAD

SELECT * FROM CIUDAD4

-- MERGE: MEZCLAR
-- HAY UNA TABLA ORIGEN Y UNA TABLA DESTINO
-- RECORRE REGISTRO A REGISTRO LA TABLA ORIGEN
-- Y CON CADA REGISTRO HACE LO SIGUIENTE EN LA TABLA DESTINO:
--     SI ESE REGISTRO NO EXISTE EN EL DESTINO, LO INSERTA EN EL DESTINO
--     SI ESE REGISTRO YA EXISTE EN EL DESTINO, LO ACTUALIZA
-- Y SI EN EL DESTINO HAY UN REGISTRO QUE NO ESTA EN EL ORIGEN, LO BORRA 
--  DEL DESTINO
DROP TABLE USUARIOS
DROP TABLE USUARIOSACTUAL

CREATE TABLE Usuarios
(
Codigo INT PRIMARY KEY,
Nombre VARCHAR(100),
Puntos INT
) 

INSERT INTO Usuarios VALUES
(1,'Juan Perez',10),
(2,'Marco Salgado',5),
(3,'Carlos Soto',9),
(4,'Alberto Ruiz',12),
(5,'Alejandro Castro',5)

CREATE TABLE UsuariosActual
(
Codigo INT PRIMARY KEY,
Nombre VARCHAR(100),
Puntos INT
) 

INSERT INTO UsuariosActual VALUES
(1,'Juan Perez',12),
(2,'Marco Salgado',11),
(4,'Alberto Ruiz Castro',4),
(5,'Alejandro Castro',5),
(6,'Pablo Ramos',8)

SELECT * FROM Usuarios
SELECT * FROM UsuariosActual

MERGE Usuarios AS TARGET        -- TABLA DESTINO
USING UsuariosActual AS SOURCE  -- TABLA ORIGEN
ON (TARGET.Codigo = SOURCE.Codigo)
WHEN MATCHED AND (TARGET.Nombre <> SOURCE.Nombre OR
		TARGET.Puntos <> SOURCE.Puntos) THEN
	UPDATE SET TARGET.Nombre = SOURCE.Nombre,
	           TARGET.Puntos = SOURCE.Puntos
WHEN NOT MATCHED BY TARGET THEN
   INSERT (Codigo, Nombre, Puntos)
   VALUES (SOURCE.Codigo, SOURCE.Nombre, SOURCE.Puntos)
WHEN NOT MATCHED BY SOURCE THEN
   DELETE;

-- **************************************************************************** --
-- **                    CLASE NOVIEMBRE 25                                  ** --
-- **************************************************************************** --

-- COMO SUBTOTALIZAR DATOS POR ...... CIERTOS CAMPOS
USE FERIAFLORES

CREATE TABLE EMPLEADO6
(CODIGODEP SMALLINT,
CODIGOCARGO SMALLINT,
CEDULA BIGINT PRIMARY KEY,
NOMBRE VARCHAR(30),
SALARIO MONEY)

INSERT INTO EMPLEADO6 VALUES
(1, 10, 5000, 'HUGO ISAZA', 6300000),
(1, 10, 6000, 'LUIS GOMEZ', 1200000),
(1, 10, 7000, 'TERESA OBANDO', 4500000),
(1, 20, 8000, 'MARIA BERNAL', 4100000),
(1, 20, 9000, 'ESMERALDA FRANCO', 1000000),
(2, 10, 1000, 'CAROLINA MERINO', 8200000),
(2, 10, 2000, 'SARA CALLE', 5300000),
(2, 20, 3000, 'CAMILA ZEA', 4800000),
(3, 10, 4000, 'PEDRO LOPEZ', 1100000),
(3, 20, 1100, 'JOHN VELEZ', 7000000),
(3, 20, 1200, 'PAULA MOLANO', 4100000),
(3, 30, 1300, 'PAMELA ORTIZ', 5200000)


CREATE TABLE DEPARTAMENTO6
(CODIGO SMALLINT PRIMARY KEY,
NOMBRE VARCHAR(20))


CREATE TABLE CARGO6
(CODIGO SMALLINT PRIMARY KEY,
NOMBRE VARCHAR(20))

INSERT INTO DEPARTAMENTO6 VALUES
(1, 'SISTEMAS'),
(2, 'CARTERA'),
(3, 'GERENCIA')

INSERT INTO CARGO6 VALUES
(10, 'ANALISTA'),
(20, 'OPERADOR'),
(30, 'GERENTE')

SELECT CODIGODEP, CODIGOCARGO, SUM(SALARIO)
FROM EMPLEADO6
GROUP BY CODIGODEP, CODIGOCARGO


-- ROLLUP PERMITE TOTALIZAR POR JERARQUIA DE CAMPOS.

SELECT CODIGODEP, CODIGOCARGO, SUM(SALARIO)
FROM EMPLEADO6
GROUP BY ROLLUP(CODIGOCARGO, CODIGODEP)

SELECT CODIGODEP, CODIGOCARGO, SUM(SALARIO)
FROM EMPLEADO6
GROUP BY ROLLUP(CODIGODEP, CODIGOCARGO)

-- CLAUSULA CUBE
SELECT DP.NOMBRE AS 'NOMBRE DEPARTAMENTO', 
       CG.NOMBRE AS 'NOMBRE CARGO', SUM(E.SALARIO) AS 'TOTAL SALARIOS'
FROM EMPLEADO6 E INNER JOIN DEPARTAMENTO6 DP
ON E.CODIGODEP = DP.CODIGO
INNER JOIN CARGO6 CG
ON E.CODIGOCARGO = CG.CODIGO
WHERE CODIGODEP < 60
GROUP BY ROLLUP(CG.NOMBRE, DP.NOMBRE)

-- ESTE ROLLUP TOTALIZA SOLAMENTE POR CARGO

SELECT DP.NOMBRE AS 'NOMBRE DEPARTAMENTO', 
       CG.NOMBRE AS 'NOMBRE CARGO', SUM(E.SALARIO) AS 'TOTAL SALARIOS'
FROM EMPLEADO6 E INNER JOIN DEPARTAMENTO6 DP
ON E.CODIGODEP = DP.CODIGO
INNER JOIN CARGO6 CG
ON E.CODIGOCARGO = CG.CODIGO
WHERE CODIGODEP < 60
GROUP BY CUBE(CG.NOMBRE, DP.NOMBRE)

-- EL CUBE TOTALIZA POR CARGO Y TAMBIEN POR DEPARTAMENTO...EL CUBE HACE TODAS
-- LAS POSIBLES COMBINACIONES.


-- TRIGGER INSTEAD OF
-- EN VEZ DE EJECUTAR LA ACCION QUE DISPARO EL TRIGGER (INSERT, UPDATE O DELETE),
-- EJECUTA LAS ACCIONES DEL TRIGGER.

-- CASO 1
DROP TABLE EMPLEADO11
CREATE TABLE EMPLEADO11
(DOCUMENTO VARCHAR(8) PRIMARY KEY,
NOMBRE VARCHAR(30),
DOMICILIO VARCHAR(30)
)

DROP TABLE CLIENTES
CREATE TABLE CLIENTES
(DOCUMENTO VARCHAR(8) PRIMARY KEY,
NOMBRE VARCHAR(30),
DOMICILIO VARCHAR(30)
)

DROP VIEW VISTA_EMPLEADOS_CLIENTES
CREATE VIEW VISTA_EMPLEADOS_CLIENTES AS
  SELECT DOCUMENTO, NOMBRE, DOMICILIO, 'EMPLEADO' AS CONDICION
  FROM EMPLEADO11
  UNION
  SELECT DOCUMENTO, NOMBRE, DOMICILIO, 'CLIENTE'
  FROM CLIENTES

DROP TRIGGER REDIRIGIR
CREATE TRIGGER REDIRIGIR ON VISTA_EMPLEADOS_CLIENTES INSTEAD OF INSERT AS
  INSERT INTO EMPLEADO11
    SELECT DOCUMENTO, NOMBRE, DOMICILIO
	FROM INSERTED WHERE CONDICION = 'EMPLEADO'
    
  INSERT INTO CLIENTES
    SELECT DOCUMENTO, NOMBRE, DOMICILIO
	FROM INSERTED WHERE CONDICION = 'CLIENTE'

INSERT INTO VISTA_EMPLEADOS_CLIENTES VALUES('22222222','Ana Acosta', 'Avellaneda 345','empleado');
INSERT INTO VISTA_EMPLEADOS_CLIENTES VALUES('23333333','Bernardo Bustos', 'Bulnes 587','cliente');

SELECT * FROM EMPLEADO11
SELECT * FROM CLIENTES
SELECT * FROM VISTA_EMPLEADOS_CLIENTES

-- CASO 2
DROP TABLE EMPLEADO12
CREATE TABLE EMPLEADO12
(CEDULA BIGINT PRIMARY KEY,
NOMBRE VARCHAR(30) NOT NULL,
EDAD SMALLINT)

DROP TABLE ENTREVISTA_EXTRA_EMPLEADO
CREATE TABLE ENTREVISTA_EXTRA_EMPLEADO
(CEDULA BIGINT,
NOMBRE VARCHAR(30),
EDAD SMALLINT)

USE DESFILE
DROP TRIGGER VERIFICAR_ENTREVISTA_EXTRA
CREATE TRIGGER VERIFICAR_ENTREVISTA_EXTRA ON EMPLEADO12 INSTEAD OF INSERT AS
  DECLARE @ED SMALLINT
  DECLARE @CD BIGINT
  DECLARE @NM VARCHAR(30)

  SELECT @ED = EDAD, @CD = CEDULA, @NM = NOMBRE
  FROM INSERTED

  IF (@ED < 30)
    INSERT INTO ENTREVISTA_EXTRA_EMPLEADO VALUES (@CD, @NM, @ED)
  ELSE
    INSERT INTO EMPLEADO12 VALUES (@CD, @NM, @ED)

INSERT INTO EMPLEADO12 VALUES (5000,'LINA LOPEZ',29)
SELECT * FROM EMPLEADO12
SELECT * FROM ENTREVISTA_EXTRA_EMPLEADO

INSERT INTO EMPLEADO12 VALUES (6000,'MONICA TAMAYO',31)
SELECT * FROM EMPLEADO12
SELECT * FROM ENTREVISTA_EXTRA_EMPLEADO

-- CALCULO DE ATRIBUTOS DERIVADOS CON VALORES DE CAMPOS DE OTRAS TABLAS

USE FERIAFLORES
CREATE TABLE PRODUCTO
(CODIGO BIGINT PRIMARY KEY,
NOMBRE VARCHAR(30),
PRECIOUNI MONEY)

INSERT INTO PRODUCTO VALUES (1,'JABON',500),(2,'ARROZ',1500),(3,'YOGURT',2000)

SELECT * FROM PRODUCTO

CREATE TABLE DETALLE_VENTA
(NUMFAC BIGINT NOT NULL,
CODPROD BIGINT NOT NULL,
CANTIDAD INT,
VALORTOTAL AS (SELECT (DV.CANTIDAD * P.PRECIOUNI) FROM DETALLE_VENTA DV
              INNER JOIN PRODUCTO P
			  ON P.CODIGO = DV.CODPROD))

CREATE TABLE DETALLE_VENTA
(NUMFAC BIGINT NOT NULL,
CODPROD BIGINT NOT NULL,
CANTIDAD INT,
VALORTOTAL MONEY)

create TRIGGER CALCULAR_VALOR ON DETALLE_VENTA AFTER INSERT AS
DECLARE @CANT INT
DECLARE @PRECUNI MONEY
DECLARE @NF BIGINT
DECLARE @CP BIGINT

  SELECT @CANT = CANTIDAD, @PRECUNI = PRECIOUNI, @NF = NUMFAC, @CP = CODPROD
  FROM INSERTED INNER JOIN PRODUCTO
       ON CODPROD = CODIGO
  UPDATE DETALLE_VENTA
    SET VALORTOTAL = @CANT * @PRECUNI
	WHERE NUMFAC = @NF AND CODPROD = @CP

INSERT INTO DETALLE_VENTA(NUMFAC,CODPROD,CANTIDAD) VALUES (100,1,50)

SELECT * FROM DETALLE_VENTA

-- COMMON TABLE EXPRESSIONS

WITH CTE1 (NOMBRE_ALCALDE, EDAD_ALCALDE) AS
(
  SELECT A.NOMBRE, A.EDAD
  FROM ALCALDE A
  WHERE A.EDAD > 30
)
SELECT * FROM CTE1

USE LIGABETPLAY1

WITH EXPRE(EQLOC, SUMGOL, RANKGOL) AS 
    (SELECT EQUIPOLOCAL, SUM(GOLLOCAL),
    RANK() OVER (ORDER BY SUM(GOLLOCAL) DESC) rango
    FROM PARTIDO
    GROUP BY EQUIPOLOCAL)
                              
SELECT EQLOC, SUMGOL FROM EXPRE WHERE RANKGOL=1












































































-- 










